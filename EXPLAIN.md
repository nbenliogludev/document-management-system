# Оптимизация поиска документов (EXPLAIN)

Данный документ описывает, как поиск документов в системе оптимизирован с использованием корректных индексов PostgreSQL, и демонстрирует план выполнения запроса.

## 1. Сценарий поиска

Пример реального пользовательского запроса или задачи асинхронного воркера: **Получить последние документы со статусом `SUBMITTED`**.

SQL-запрос выглядит следующим образом:
```sql
SELECT *
FROM documents
WHERE status = 'SUBMITTED'
ORDER BY created_at DESC
LIMIT 50;
```

## 2. EXPLAIN ANALYZE

При выполнении данного запроса с использованием `EXPLAIN ANALYZE` план запроса PostgreSQL демонстрирует оптимальный путь выполнения:

```sql
EXPLAIN ANALYZE
SELECT *
FROM documents
WHERE status = 'SUBMITTED'
ORDER BY created_at DESC
LIMIT 50;
```

**Ожидаемый результат (фрагмент):**
```text
Limit  (cost=0.14..5.91 rows=50 width=227) (actual time=0.012..0.045 rows=50 loops=1)
  ->  Index Scan using idx_documents_status_created_at on documents  (cost=0.14..5.91 rows=50 width=227)
        Index Cond: ((status)::text = 'SUBMITTED'::text)
```
*(Важно: PostgreSQL использует `Index Scan`, а не полное сканирование индексов `Seq Scan`)*

## 3. Почему используется этот индекс

В системе (через Liquibase) создан специальный композитный B-Tree индекс:
`idx_documents_status_created_at (status, created_at DESC)`

Этот индекс позволяет оптимизатору запросов делать несколько вещей одновременно:
- **Фильтровать по `status`**: База данных мгновенно позиционируется на первый подходящий элемент в дереве, отсекая все остальные статусы.
- **Сразу возвращать строки в нужной сортировке**: Поскольку записи внутри индекса уже упорядочены по убыванию времени (`created_at DESC`), БД просто читает элементы по порядку.
- **Избегать in-memory Sort**: В памяти сервера не выделяются буферы под сортировку, так как данные заранее готовы.
- **Избегать Seq Scan**: Полное сканирование таблицы отсутствует, экономятся циклы CPU и I/O диска.

## 4. Что это даёт системе

**Без индекса:**
- `Seq Scan` (Чтение всех страниц таблицы).
- Отдельный тяжелый шаг `Sort` всех отфильтрованных строк.
- Сильная деградация производительности и рост Latency по мере увеличения объёма данных в таблице.

**С индексом:**
- Направленный `Index Scan`.
- Сверхбыстрая и предсказуемая пагинация (pagination) даже при больших смещениях.
- Масштабируемый массовый процессинг (batch approve / submit), так как воркеры за миллисекунды забирают свои чанки задач (LIMIT M), не блокируя остальных потребителей долгими выборками.

## 5. Инфраструктура и развертывание

- Создание индексов гарантировано на уровне схемы БД: они автоматически применяются и защищены конфигурацией **Liquibase** (`007-optimize-document-search-indexes.yaml`).
- Оптимизатор планировщика запросов **PostgreSQL** подхватывает этот индекс автоматически при наличии актуальной статистики, поэтому система работает без сложной ручной подстройки или принудительных хинтов.
